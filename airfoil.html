<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    </head>
    <body>
        <div id="#pts"></div>
        <div id="#elem"></div>
        <div id="infl"></div>
        <canvas id="#airfoil" width=1010 height=310 style="width:1000px; height:300px"></canvas>
        <canvas id="#cpplot" width=1010 height=1010 style="width:1000px; height:1000px"></canvas>
        <script src="lalolib.js"></script>
        <script src="lalolibworker.js"></script>
        <script>
            class Point {
                constructor(XorR, YorTheta, inPolarCoordinates = false) {
                    if(!inPolarCoordinates) {
                        this._x = XorR;
                        this._y = YorTheta;
                        this._R = Math.sqrt(XorR*XorR + YorTheta*YorTheta);
                        this._theta = Math.atan2(YorTheta, XorR);
                    } else {
                        this._R = XorR;
                        this._theta = YorTheta;
                        this._x = XorR * Math.cos(YorTheta);
                        this._y = XorR * Math.sin(YorTheta);
                    }
                }

                setPosition(XorR, YorTheta, inPolarCoordinates = false) {
                    if(!inPolarCoordinates) {
                        this._x = XorR;
                        this._y = YorTheta;
                        this._R = Math.sqrt(XorR*XorR + YorTheta*YorTheta);
                        this._theta = Math.atan2(YorTheta, XorR);
                    } else {
                        this._R = XorR;
                        this._theta = YorTheta;
                        this._x = XorR * Math.cos(YorTheta);
                        this._y = XorR * Math.sin(YorTheta);
                    }
                }

                get x() { return this._x; }
                get y() { return this._y; }
                get R() { return this._R; }
                get theta() { return this._theta; }
            }

            class DoubletConstant2D {
                constructor(point1, point2) {
                    this.p1 = point1;
                    this.p2 = point2;
                }

                transformToElementCoordinates(point) {
                    let dx = point.x - this.p1.x;
                    let dy = point.y - this.p1.y;
                    let R = Math.sqrt(dx*dx + dy*dy);
                    let theta = Math.atan2(dy, dx);

                    return new Point(R, theta, true);
                }

                getInducedPotentialAt(point) {
                    let pointInLocal = this.transformToElementCoordinates(point);
                    let atan2AtPoint1 = Math.atan2(pointInLocal.z, pointInLocal.x - this.point1.x);
                    let atan2AtPoint2 = Math.atan2(pointInLocal.z, pointInLocal.x - this.point2.x);
                    let Phi = 1 / (2* Math.PI) * (atan2AtPoint2 - atan2AtPoint1);
                }

                getInducedVelocityAt(point) {
                    let p = this.transformToElementCoordinates(point);
                    let p1 = this.transformToElementCoordinates(this.p1);
                    let p2 = this.transformToElementCoordinates(this.p2);
                    let ru1 = p.y / ((p.x-p1.x)*(p.x-p1.x) + p.y*p.y);
                    let ru2 = p.y / ((p.x-p2.x)*(p.x-p2.x) + p.y*p.y);
                    let rw1 = (p.x - p1.x) / ((p.x-p1.x)*(p.x-p1.x) + p.y*p.y);
                    let rw2 = (p.x - p2.x) / ((p.x-p2.x)*(p.x-p2.x) + p.y*p.y);
                    let u = -1 / (2 * Math.PI) * (ru1 - ru2);
                    let w = 1 / (2 * Math.PI) * (rw1 - rw2);
                    return {
                        u: u,
                        w: w
                    }
                }

                getNormalVector() {
                    let dx = this.p2.x - this.p1.x;
                    let dy = this.p2.y - this.p1.y;
                    let l = Math.sqrt(dx*dx + dy*dy);
                    return {
                        x: dy / l,
                        y : -dx / l
                    }
                }

                getTangentialVector() {
                    return {
                        x: this.getNormalVector().y,
                        y: -this.getNormalVector().x
                    }
                }

                getCollocationPoint() {
                    return new Point((this.p1.x + this.p2.x) / 2, (this.p1.y + this.p2.y) / 2, false);
                }

                length() {
                    let dx = this.p2.x - this.p1.x;
                    let dy = this.p2.y - this.p1.y;
                    let l = Math.sqrt(dx*dx + dy*dy);
                    return l;
                }
            }

            class DoubletConstant2DWake {
                constructor(point1) {
                    this.p1 = point1;
                }

                transformToElementCoordinates(point) {
                    let dx = point.x - this.p1.x;
                    let dy = point.y - this.p1.y;
                    let R = Math.sqrt(dx*dx + dy*dy);
                    let theta = Math.atan2(dy, dx);

                    return new Point(R, theta, true);
                }

                getInducedVelocityAt(point) {
                    let p = this.transformToElementCoordinates(point);
                    let ru1 = p.y / (p.x*p.x + p.y*p.y);
                    let rw1 = p.x / (p.x*p.x + p.y*p.y);
                    let u = -1 / (2 * Math.PI) * ru1;
                    let w = 1 / (2 * Math.PI) * rw1;
                    return {
                        u: u,
                        w: w
                    }
                }
            }

            var canvas = document.getElementById("#airfoil");
            var canvas2D = canvas.getContext("2d");
            canvas2D.beginPath();
            canvas2D.moveTo(1005, 155);

            var alpha = 1.0; // in degrees!
            var airspeed = 1.0;
            var freeStream = {
                u: airspeed * Math.cos(alpha * Math.PI / 180),
                w: airspeed * Math.sin(alpha * Math.PI / 180)
            }
            
            var halfNumberOfElements = 10;
            var numberOfElements = 2 * halfNumberOfElements;
            var points = [];
            var elements = [];
            for(let i = 0; i <= numberOfElements; i++) {
                let theta = Math.PI * i / numberOfElements;
                let x = Math.pow(Math.cos(theta), 2);
                let sqrx = Math.sqrt(x);
                let x2 = Math.pow(x, 2);
                let x3 = Math.pow(x, 3);
                let x4 = Math.pow(x, 4);
                let y = (i > halfNumberOfElements ? -1 : 1) * 5 * 0.12 * (0.2969 * sqrx - 0.1260 * x - 0.3516 * x2 + 0.2843 * x3 - 0.1015 * x4);
                let thisPoint = new Point(x, y);
                points.push(thisPoint);
                if(i >= 1) {
                    let lastPoint = points[points.length - 2];
                    elements.push(new DoubletConstant2D(lastPoint, thisPoint));
                }
                canvas2D.lineTo(5 + 1000 * x, 155 - 1000 * y);
            }
            var wakeElement = new DoubletConstant2DWake(points[0]);

            canvas2D.stroke();
            for(let element of elements) {
                let controlPoint = element.getCollocationPoint();
                canvas2D.beginPath();
                canvas2D.arc(5 + controlPoint.x * 1000, 155 - controlPoint.y * 1000, 4, 0, 2 * Math.PI);
                canvas2D.strokeStyle = "blue";
                canvas2D.stroke();
            }

            var influenceElement = document.getElementById("infl");

            var lab = new Lalolab("mylab",false,"./");

            lab.do(`A = zeros(${numberOfElements+1},${numberOfElements+1})`);
            for(let from = 0; from < numberOfElements; from++) {
                for(let to = 0; to < numberOfElements; to++) {
                    let fromElement = elements[from];
                    let toElement = elements[to];
                    let inducedVelocity = fromElement.getInducedVelocityAt(toElement.getCollocationPoint());
                    let influence = inducedVelocity.u * toElement.getNormalVector().x + inducedVelocity.w * toElement.getNormalVector().y;
                    lab.do(`A[${to},${from}] = ${influence}`);
                }
                let wakeToElement = elements[from];
                let inducedVelocity = wakeElement.getInducedVelocityAt(wakeToElement.getCollocationPoint());
                let influence = inducedVelocity.u * wakeToElement.getNormalVector().x + inducedVelocity.w * wakeToElement.getNormalVector().y;
                lab.do(`A[${from},${numberOfElements}] = ${influence}`);
            }
            lab.do(`A[${numberOfElements},0] = 1.0`);
            lab.do(`A[${numberOfElements},${numberOfElements}-1] = -1.0`);
            lab.do(`A[${numberOfElements},${numberOfElements}] = 1.0`);

            lab.do(`R = zeros(${numberOfElements}+1)`);
            for(let i = 0; i < numberOfElements; i++) {
                let element = elements[i];
                let localFreeStreamComponent = -(freeStream.u * element.getNormalVector().x + freeStream.w * element.getNormalVector().y);
                lab.do(`R[${i}] = ${localFreeStreamComponent}`);
            }

            lab.do("Mu = solve(A, R)", res => {
                influenceElement.innerHTML = "System solved, doublet strengths calculated";
            });

            var doubletStrengths = [];
            for(let i = 0; i < numberOfElements+1; i++) {
                lab.do(`mu = Mu[${i}]`, mu => {
                    doubletStrengths.push(mu);
                });
            }

            lab.do(``, () => {
                var wakeDoubletStrength = doubletStrengths.pop();

                var inducedTangentialVelocities = [];
                for(let to = 0; to < numberOfElements; to++) {
                    let inducedTangentialVelocity = 0.0;
                    for(let from = 0; from < numberOfElements; from++) {
                        let inducedVelocity = elements[from].getInducedVelocityAt(elements[to].getCollocationPoint());
                        let tangentialComponent = inducedVelocity.u * elements[to].getTangentialVector().x + inducedVelocity.w * elements[to].getTangentialVector().y;
                        inducedTangentialVelocity += doubletStrengths[from] * tangentialComponent;
                    }
                    let inducedVelocity = wakeElement.getInducedVelocityAt(elements[to].getCollocationPoint());
                    let tangentialComponent = inducedVelocity.u * elements[to].getTangentialVector().x + inducedVelocity.w * elements[to].getTangentialVector().y;
                    inducedTangentialVelocity += wakeDoubletStrength * tangentialComponent;
                    inducedTangentialVelocities.push(inducedTangentialVelocity);
                }
                var pressureCoefficients = [];
                for(let i = 0; i < numberOfElements; i++) {
                    let freeStreamTangentialComponent = freeStream.u * elements[i].getTangentialVector().x + freeStream.w * elements[i].getTangentialVector().y;
                    let totalTangentialComponent = freeStreamTangentialComponent + inducedTangentialVelocities[i];
                    let cp = 1 - totalTangentialComponent*totalTangentialComponent;
                    pressureCoefficients.push(cp);
                }
                console.log(JSON.stringify(pressureCoefficients));

                var lift = 0.0;
                for(let i = 0; i < numberOfElements; i++) {
                    lift += pressureCoefficients[i] * elements[i].length() * elements[i].getNormalVector().y;
                }
                console.log(`Total lift ${lift}`);

                canvas = document.getElementById("#cpplot");
                canvas2D = canvas.getContext("2d");
                canvas2D.stroke();
                for(let i = 0; i < numberOfElements; i++) {
                    let controlPoint = elements[i].getCollocationPoint();
                    canvas2D.beginPath();
                    canvas2D.arc(5 + controlPoint.x * 1000, 338 - pressureCoefficients[i] * 333, 4, 0, 2 * Math.PI);
                    canvas2D.strokeStyle = "blue";
                    canvas2D.stroke();
                }            
            });
        </script>
    </body>
</html>